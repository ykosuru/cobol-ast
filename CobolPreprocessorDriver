import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;
import java.io.*;
import java.nio.charset.Charset;
import java.nio.file.*;
import java.util.*;
import java.util.regex.*;

public class CobolPreprocessorDriver extends CobolPreprocessorBaseVisitor<StringBuilder> {
    private StringBuilder output = new StringBuilder();
    private static final String NEWLINE = "\n";
    private static final String EXEC_CICS_TAG = "*>>EXECCICS";
    private static final String EXEC_SQL_TAG = "*>>EXECSQL";
    private static final String EXEC_SQLIMS_TAG = "*>>EXECSQLIMS";
    private static final String EXEC_END_TAG = "*>>END-EXEC";
    private static final String COMMENT_TAG = "*>";
    private static final String COMMENT_ENTRY_TAG = "*>>CE";
    private static final String CHAR_ASTERISK = "*";
    private static final String CHAR_SLASH = "/";
    private static final String CHAR_D = "D";
    private static final String CHAR_D_ = "d";
    private Map<String, String> copyBooks = new HashMap<>();
    private List<ReplaceContext> replaceContexts = new ArrayList<>();
    private CobolSourceFormatEnum format = CobolSourceFormatEnum.FIXED;
    private boolean strictMode = true;

    private static interface CobolParserParams {
        CobolSourceFormatEnum getFormat();
        File getCopyBookDirectory();
        List<File> getCopyBookDirectories();
        List<String> getCopyBookExtensions();
        Charset getCharset();
        boolean isStrictMode();
    }

    private static enum CobolSourceFormatEnum {
        FIXED(Pattern.compile("^(.{0,6})(.{0,1})(.{0,4})(.{0,60})(.*)?$"), true, 80),
        TANDEM(Pattern.compile("^(.{0,1})(.{0,131})(.*)?$"), false, 132),
        VARIABLE(Pattern.compile("^(.{0,6})(.{0,1})(.{0,4})(.{0,252})(.*)?$"), true, 256);

        private final Pattern pattern;
        private final boolean commentEntryMultiLine;
        private final int maxLineLength;

        CobolSourceFormatEnum(Pattern pattern, boolean commentEntryMultiLine, int maxLineLength) {
            this.pattern = pattern;
            this.commentEntryMultiLine = commentEntryMultiLine;
            this.maxLineLength = maxLineLength;
        }

        public Pattern getPattern() {
            return pattern;
        }

        public boolean isCommentEntryMultiLine() {
            return commentEntryMultiLine;
        }

        public int getMaxLineLength() {
            return maxLineLength;
        }
    }

    private static class CobolParserParamsImpl implements CobolParserParams {
        private CobolSourceFormatEnum format = CobolSourceFormatEnum.FIXED;
        private File copyBookDirectory = new File(".");
        private List<File> copyBookDirectories = List.of(new File("."));
        private List<String> copyBookExtensions = List.of("cbl", "cpy");
        private Charset charset = Charset.defaultCharset();
        private boolean strictMode = true;

        @Override
        public CobolSourceFormatEnum getFormat() {
            return format;
        }

        public void setFormat(CobolSourceFormatEnum format) {
            this.format = format;
        }

        @Override
        public File getCopyBookDirectory() {
            return copyBookDirectory;
        }

        public void setCopyBookDirectory(File copyBookDirectory) {
            this.copyBookDirectory = copyBookDirectory;
            this.copyBookDirectories = List.of(copyBookDirectory);
        }

        @Override
        public List<File> getCopyBookDirectories() {
            return copyBookDirectories;
        }

        public void setCopyBookDirectories(List<File> copyBookDirectories) {
            this.copyBookDirectories = copyBookDirectories != null ? copyBookDirectories : List.of();
            this.copyBookDirectory = copyBookDirectories != null && !copyBookDirectories.isEmpty() ? copyBookDirectories.get(0) : new File(".");
        }

        @Override
        public List<String> getCopyBookExtensions() {
            return copyBookExtensions;
        }

        public void setCopyBookExtensions(List<String> copyBookExtensions) {
            this.copyBookExtensions = copyBookExtensions != null ? copyBookExtensions : List.of("cbl", "cpy");
        }

        @Override
        public Charset getCharset() {
            return charset;
        }

        public void setCharset(Charset charset) {
            this.charset = charset != null ? charset : Charset.defaultCharset();
        }

        @Override
        public boolean isStrictMode() {
            return strictMode;
        }

        public void setStrictMode(boolean strictMode) {
            this.strictMode = strictMode;
        }
    }

    private static class CobolLine {
        private final String content;
        private final String sequenceArea;
        private final String indicatorArea;
        private final String areaA;
        private final String areaB;
        private final String comment;
        private final boolean isContinuation;

        CobolLine(String content, String sequenceArea, String indicatorArea, String areaA, String areaB, String comment, boolean isContinuation) {
            this.content = content != null ? content.trim() : "";
            this.sequenceArea = sequenceArea != null ? sequenceArea.trim() : "";
            this.indicatorArea = indicatorArea != null ? indicatorArea : "";
            this.areaA = areaA != null ? areaA.trim() : "";
            this.areaB = areaB != null ? areaB.trim() : "";
            this.comment = comment != null ? comment.trim() : "";
            this.isContinuation = isContinuation;
        }

        public String getContent() {
            return content;
        }

        public String getSequenceArea() {
            return sequenceArea;
        }

        public String getIndicatorArea() {
            return indicatorArea;
        }

        public String getAreaA() {
            return areaA;
        }

        public String getAreaB() {
            return areaB;
        }

        public String getComment() {
            return comment;
        }

        public boolean isContinuation() {
            return isContinuation;
        }
    }

    private static class CobolLineWriterImpl {
        public String serialize(List<CobolLine> lines) {
            StringBuilder result = new StringBuilder();
            for (CobolLine line : lines) {
                if (!line.getContent().isEmpty()) {
                    result.append(line.getContent()).append(NEWLINE);
                }
            }
            return result.toString();
        }
    }

    private interface CobolDocumentParser {
        String processLines(String code, CobolParserParams params) throws IOException;
    }

    private class CobolDocumentParserImpl implements CobolDocumentParser {
        private final Pattern processPattern = Pattern.compile("(?i)^\\s*(CBL|PROCESS)\\s+(.+)$");

        @Override
        public String processLines(String code, CobolParserParams params) throws IOException {
            // Preprocess code to normalize PROCESS/CBL directives
            StringBuilder normalizedCode = new StringBuilder();
            BufferedReader reader = new BufferedReader(new StringReader(code));
            String line;
            while ((line = reader.readLine()) != null) {
                Matcher matcher = processPattern.matcher(line);
                if (matcher.matches()) {
                    normalizedCode.append("CBL ").append(matcher.group(2).trim()).append(NEWLINE);
                } else {
                    normalizedCode.append(line).append(NEWLINE);
                }
            }

            try {
                CharStream input = CharStreams.fromString(normalizedCode.toString());
                CobolPreprocessorLexer lexer = new CobolPreprocessorLexer(input);
                CommonTokenStream tokens = new CommonTokenStream(lexer);
                CobolPreprocessorParser parser = new CobolPreprocessorParser(tokens);
                parser.removeErrorListeners();
                
                // Only add error listener for actual syntax errors in strict mode
                if (params.isStrictMode()) {
                    parser.addErrorListener(new BaseErrorListener() {
                        @Override
                        public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line,
                                int charPositionInLine, String msg, RecognitionException e) {
                            // Only throw for actual parse errors, not diagnostic warnings
                            if (e != null) {
                                System.out.println(String.format("Parse error at line %d:%d: %s", line, charPositionInLine, msg));
                                throw new RuntimeException(msg);
                            } else {
                                System.out.println(String.format("Parse warning at line %d:%d: %s", line, charPositionInLine, msg));
                            }
                        }
                    });
                }
                
                CobolPreprocessorParser.StartRuleContext tree = parser.startRule();
                CobolPreprocessorDriver visitor = new CobolPreprocessorDriver();
                visitor.copyBooks = copyBooks; // Share copybooks
                visitor.replaceContexts = replaceContexts; // Share replace contexts
                visitor.strictMode = params.isStrictMode();
                return visitor.visitStartRule(tree).toString();
            } catch (Exception e) {
                throw new IOException("Failed to parse COBOL code: " + e.getMessage(), e);
            }
        }
    }

    private static class ReplaceRule {
        String replaceable;
        String replacement;
        Pattern pattern;

        ReplaceRule(String replaceable, String replacement) {
            this.replaceable = replaceable;
            this.replacement = replacement;
            
            if (replaceable.startsWith("==") && replaceable.endsWith("==")) {
                String content = replaceable.substring(2, replaceable.length() - 2);
                this.pattern = Pattern.compile(Pattern.quote(content), Pattern.CASE_INSENSITIVE);
                System.out.println("DEBUG: Created pseudo-text pattern: " + this.pattern.pattern());
            } else {
                this.pattern = Pattern.compile("\\b" + Pattern.quote(replaceable) + "\\b", Pattern.CASE_INSENSITIVE);
                System.out.println("DEBUG: Created word boundary pattern: " + this.pattern.pattern());
            }
        }
        
    }

    private static class ReplaceContext {
        List<ReplaceRule> rules = new ArrayList<>();

        void addRule(String replaceable, String replacement) {
            rules.add(new ReplaceRule(replaceable, replacement));
        }

        String apply(String text) {
            String result = text;
            for (ReplaceRule rule : rules) {
                System.out.println("DEBUG: Applying rule '" + rule.replaceable + "' -> '" + rule.replacement + "' to: '" + result + "'");
                
                // Handle replacement - if replacement is pseudo-text, extract content
                String replaceWith = rule.replacement;
                if (replaceWith.startsWith("==") && replaceWith.endsWith("==")) {
                    replaceWith = replaceWith.substring(2, replaceWith.length() - 2);
                }
                
                String beforeReplace = result;
                result = rule.pattern.matcher(result).replaceAll(replaceWith);
                
                if (!beforeReplace.equals(result)) {
                    System.out.println("DEBUG: Rule applied! '" + beforeReplace + "' -> '" + result + "'");
                } else {
                    System.out.println("DEBUG: Rule pattern '" + rule.pattern.pattern() + "' did not match");
                }
            }
            return result;
        }
    }

    public String process(File cobolFile, CobolParserParams params) throws IOException {
        if (cobolFile == null || !cobolFile.exists()) {
            String msg = String.format("Input file does not exist: %s",
                    cobolFile != null ? cobolFile.getAbsolutePath() : "null");
            System.out.println(msg);
            throw new IOException(msg);
        }
        if (!cobolFile.canRead()) {
            String msg = String.format("Input file is not readable: %s",
                    cobolFile.getAbsolutePath());
            System.out.println(msg);
            throw new IOException(msg);
        }
        if (cobolFile.length() == 0 && params.isStrictMode()) {
            String msg = String.format("Input file is empty: %s",
                    cobolFile.getAbsolutePath());
            System.out.println(msg);
            throw new IOException(msg);
        }
        Charset charset = params != null && params.getCharset() != null ? params.getCharset() : Charset.defaultCharset();
        System.out.println(String.format("Preprocessing file %s with line format %s and charset %s",
                cobolFile.getName(), params != null && params.getFormat() != null ? params.getFormat() : format, charset));
        String cobolFileContent = Files.readString(cobolFile.toPath(), charset);
        return process(cobolFileContent, params);
    }

    public String process(String cobolCode, CobolParserParams params) throws IOException {
        if (cobolCode == null || cobolCode.trim().isEmpty()) {
            String msg = "Input COBOL code is null or empty";
            System.out.println(msg);
            throw new IOException(msg);
        }
        if (params == null) {
            System.out.println("CobolParserParams is null, using default settings.");
            params = new CobolParserParamsImpl();
        }
        strictMode = params.isStrictMode();
        format = params.getFormat() != null ? params.getFormat() : CobolSourceFormatEnum.FIXED;
        loadCopyBooks(params.getCopyBookDirectories(), params.getCopyBookExtensions(), params.getCharset(), new HashSet<>());
        List<CobolLine> lines = readLines(cobolCode, params);
        List<CobolLine> rewrittenLines = rewriteLines(lines);
        return parseDocument(lines, params);
    }

    protected List<CobolLine> readLines(String cobolCode, CobolParserParams params) throws IOException {
        List<CobolLine> result = new ArrayList<>();
        BufferedReader reader = new BufferedReader(new StringReader(cobolCode));
        String line;
        
        while ((line = reader.readLine()) != null) {
            // Skip empty lines
            if (line.trim().isEmpty()) {
                continue;
            }
            
            // Parse COBOL fixed format: cols 1-6 (seq), 7 (indicator), 8-72 (content), 73-80 (id)
            if (line.length() >= 72) {
                String sequenceArea = line.substring(0, 6).trim();
                String indicatorArea = line.length() > 6 ? line.substring(6, 7) : "";
                String contentArea = line.length() > 7 ? line.substring(7, 72).trim() : "";
                String identificationArea = line.length() > 72 ? line.substring(72).trim() : "";
                
                // Skip if content area is empty (pure line number lines)
                if (contentArea.isEmpty()) {
                    continue;
                }
                
                // Check for comments
                if (contentArea.startsWith("*")) {
                    result.add(new CobolLine(contentArea, sequenceArea, indicatorArea, "", contentArea, "", false));
                } else {
                    // Regular code line - use only the content area
                    result.add(new CobolLine(contentArea, sequenceArea, indicatorArea, "", contentArea, "", false));
                }
            } else {
                // Handle short lines
                String trimmedLine = line.trim();
                if (!trimmedLine.isEmpty() && !trimmedLine.startsWith("*")) {
                    result.add(new CobolLine(trimmedLine, "", "", "", trimmedLine, "", false));
                }
            }
        }
        
        return result;
    }
    

    protected List<CobolLine> rewriteLines(List<CobolLine> lines) {
        List<CobolLine> result = new ArrayList<>();
        boolean inCommentEntry = false;
        
        for (CobolLine line : lines) {
            String content = line.getContent();
            
            // Handle comment entry markers - but preserve them
            if (content.contains("*>>CE")) {
                inCommentEntry = true;
                result.add(line); // PRESERVE the comment entry marker
                continue;
            }
            
            // Handle lines within comment entry
            if (inCommentEntry) {
                if (content.startsWith("*") || content.trim().isEmpty()) {
                    result.add(line); // PRESERVE comment content
                    continue;
                } else {
                    inCommentEntry = false; // Exit comment mode
                    // Fall through to add the current line
                }
            }
            
            // Add all lines (including regular comments)
            result.add(line);
        }
        
        return result;
    }
    
    protected String parseDocument(List<CobolLine> lines, CobolParserParams params) throws IOException {
        String serializedLines = new CobolLineWriterImpl().serialize(lines);
        return new CobolDocumentParserImpl().processLines(serializedLines, params);
    }

    @Override
    public StringBuilder visitStartRule(CobolPreprocessorParser.StartRuleContext ctx) {
        output = new StringBuilder();
        for (int i = 0; i < ctx.getChildCount(); i++) {
            ParseTree child = ctx.getChild(i);
            if (child instanceof TerminalNode) {
                // Skip terminal nodes that are just whitespace or newlines
                String text = child.getText().trim();
                if (!text.isEmpty() && !text.equals("\n") && !text.equals("\r\n")) {
                    // Only process meaningful terminal content
                    continue;
                }
            } else {
                child.accept(this);
            }
        }
        return output;
    }

    
    @Override
    public StringBuilder visitCommentLine(CobolPreprocessorParser.CommentLineContext ctx) {
        // Preserve all comment content exactly as-is
        String commentText = ctx.getText().trim();
        output.append(commentText).append(NEWLINE);
        return output;
    }

    @Override
    public StringBuilder visitCharDataLine(CobolPreprocessorParser.CharDataLineContext ctx) {
        StringBuilder lineBuilder = new StringBuilder();
        
        for (int i = 0; i < ctx.getChildCount(); i++) {
            ParseTree child = ctx.getChild(i);
            String token = child.getText();
            
            if (i > 0 && !token.trim().isEmpty() && !token.equals(".") && !token.equals(",")) {
                lineBuilder.append(" ");
            }
            lineBuilder.append(token);
        }
        
        String text = lineBuilder.toString().trim();
        
        // Check if this is a comment line - if so, preserve as-is
        if (text.startsWith("*")) {
            output.append(text).append(NEWLINE);
            return output;
        }
        
        // Apply REPLACE transformations only to non-comment lines
        String originalText = text;
        for (ReplaceContext context : replaceContexts) {
            text = context.apply(text);
        }
        
        if (!text.isEmpty()) {
            output.append(text).append(NEWLINE);
        }
        return output;
    }
    @Override
    public StringBuilder visitCompilerOptions(CobolPreprocessorParser.CompilerOptionsContext ctx) {
        StringBuilder lineBuilder = new StringBuilder();
        
        for (int i = 0; i < ctx.getChildCount(); i++) {
            ParseTree child = ctx.getChild(i);
            String token = child.getText();
            
            if (i > 0 && !token.trim().isEmpty() && !token.equals(".") && !token.equals(",")) {
                lineBuilder.append(" ");
            }
            lineBuilder.append(token);
        }
        
        String text = lineBuilder.toString().trim();
        if (!text.isEmpty()) {
            output.append(text).append(NEWLINE);
        }
        return output;
    }

    @Override
    public StringBuilder visitCompilerOption(CobolPreprocessorParser.CompilerOptionContext ctx) {
        // This method is called for individual options within compiler options
        // The parent visitCompilerOptions will handle the reconstruction
        return output;
    }

    @Override
    public StringBuilder visitCopyStatement(CobolPreprocessorParser.CopyStatementContext ctx) {
        String copySource = ctx.copySource().getText().replaceAll("[\"'.]", "").toUpperCase();
        String copyContent = copyBooks.getOrDefault(copySource, null);
        
        if (copyContent == null) {
            String msg = "Copybook not found: " + copySource;
            System.out.println(msg);
            if (strictMode) {
                throw new RuntimeException(msg);
            }
            // Instead of adding a comment, preserve the COPY statement
            output.append("COPY ").append(copySource).append(".").append(NEWLINE);
            return output;
        }
        
        // Process the copybook content through the preprocessor recursively
        try {
            // Create a temporary params object if we don't have access to the current one
            CobolParserParamsImpl tempParams = new CobolParserParamsImpl();
            tempParams.setStrictMode(this.strictMode);
            tempParams.setFormat(this.format);
            
            CobolDocumentParserImpl parser = new CobolDocumentParserImpl();
            String processedContent = parser.processLines(copyContent, tempParams);
            output.append(processedContent);
        } catch (IOException e) {
            System.out.println("Error processing copybook: " + e.getMessage());
            if (strictMode) {
                throw new RuntimeException(e);
            }
        }
        
        return output;
    }

    @Override
    public StringBuilder visitReplaceByStatement(CobolPreprocessorParser.ReplaceByStatementContext ctx) {
        ReplaceContext context = new ReplaceContext();
        for (CobolPreprocessorParser.ReplaceClauseContext clause : ctx.replaceClause()) {
            String replaceable = clause.replaceable().getText();
            String replacement = clause.replacement().getText();
            System.out.println("DEBUG: Adding REPLACE rule: '" + replaceable + "' -> '" + replacement + "'");
            context.addRule(replaceable, replacement);
        }
        replaceContexts.add(context);
        System.out.println("DEBUG: Total active REPLACE contexts: " + replaceContexts.size());
        return output;
    }

    @Override
    public StringBuilder visitReplaceOffStatement(CobolPreprocessorParser.ReplaceOffStatementContext ctx) {
        System.out.println("DEBUG: REPLACE OFF encountered, removing last context");
        if (!replaceContexts.isEmpty()) {
            replaceContexts.remove(replaceContexts.size() - 1);
            System.out.println("DEBUG: Remaining REPLACE contexts: " + replaceContexts.size());
        }
        return output;
    }

    @Override
    public StringBuilder visitExecCicsStatement(CobolPreprocessorParser.ExecCicsStatementContext ctx) {
        StringBuilder cicsBuilder = new StringBuilder();
        cicsBuilder.append("EXEC CICS");
        
        if (ctx.charData() != null) {
            String cicsContent = reconstructCharData(ctx.charData());
            if (!cicsContent.trim().isEmpty()) {
                cicsBuilder.append(" ").append(cicsContent);
            }
        }
        
        cicsBuilder.append(" END-EXEC");
        if (ctx.DOT() != null) {
            cicsBuilder.append(".");
        }
        
        output.append(cicsBuilder.toString().trim()).append(NEWLINE);
        return output;
    }

    @Override
    public StringBuilder visitExecSqlStatement(CobolPreprocessorParser.ExecSqlStatementContext ctx) {
        StringBuilder sqlBuilder = new StringBuilder();
        sqlBuilder.append("EXEC SQL");
        
        if (ctx.charDataSql() != null) {
            String sqlContent = reconstructCharDataSql(ctx.charDataSql());
            // Filter out line numbers and sequence IDs from SQL content
            sqlContent = cleanCobolLineArtifacts(sqlContent);
            
            if (!sqlContent.trim().isEmpty()) {
                sqlBuilder.append(" ").append(sqlContent);
            }
        }
        
        sqlBuilder.append(" END-EXEC");
        if (ctx.DOT() != null) {
            sqlBuilder.append(".");
        }
        
        output.append(sqlBuilder.toString().trim()).append(NEWLINE);
        return output;
    }

    /**
     * Removes COBOL line numbers and sequence identifiers from content
     */
    private String cleanCobolLineArtifacts(String content) {
        // Remove 6-digit line numbers and 8-character sequence IDs
        String cleaned = content.replaceAll("\\b\\d{6}\\b", "")  // Remove 6-digit numbers
                            .replaceAll("\\b[A-Z0-9]{8}\\b", "")  // Remove 8-char IDs
                            .replaceAll("\\s+", " ")  // Normalize whitespace
                            .trim();
        return cleaned;
    }

    /**
     * Reconstructs charDataSql with proper spacing and formatting
     */
    private String reconstructCharDataSql(CobolPreprocessorParser.CharDataSqlContext ctx) {
        StringBuilder content = new StringBuilder();
        
        for (int i = 0; i < ctx.getChildCount(); i++) {
            ParseTree child = ctx.getChild(i);
            String token = child.getText().trim();
            
            // Skip empty tokens and newlines
            if (token.isEmpty() || token.equals("\n") || token.equals("\r\n")) {
                continue;
            }
            
            // Handle special tokens
            if (token.equals("COPY") || token.equals("REPLACE")) {
                // Add space before SQL keywords
                if (content.length() > 0) {
                    content.append(" ");
                }
                content.append(token);
            } else if (isNewlineToken(child)) {
                // Convert newlines to spaces in SQL content
                if (content.length() > 0 && !content.toString().endsWith(" ")) {
                    content.append(" ");
                }
            } else {
                // Regular content
                if (content.length() > 0 && !token.equals(".") && !token.equals(",") && 
                    !content.toString().endsWith(" ")) {
                    content.append(" ");
                }
                content.append(token);
            }
        }
        
        return content.toString().trim();
    }

    /**
     * Reconstructs charData (for EXEC CICS) with proper spacing and formatting
     */
    private String reconstructCharData(CobolPreprocessorParser.CharDataContext ctx) {
        StringBuilder content = new StringBuilder();
        
        for (int i = 0; i < ctx.getChildCount(); i++) {
            ParseTree child = ctx.getChild(i);
            String token = child.getText().trim();
            
            // Skip empty tokens and newlines
            if (token.isEmpty() || token.equals("\n") || token.equals("\r\n")) {
                continue;
            }
            
            // Handle newline tokens by converting to spaces
            if (isNewlineToken(child)) {
                if (content.length() > 0 && !content.toString().endsWith(" ")) {
                    content.append(" ");
                }
            } else {
                // Regular content - add space before token if needed
                if (content.length() > 0 && !token.equals(".") && !token.equals(",") && 
                    !content.toString().endsWith(" ")) {
                    content.append(" ");
                }
                content.append(token);
            }
        }
        
        return content.toString().trim();
    }

    /**
     * Extracts the copybook name from EXEC SQL INCLUDE statement
     */
    private String extractIncludeName(String text) {
        // Pattern to match: EXEC SQL INCLUDE copybook-name END-EXEC
        Pattern includePattern = Pattern.compile(
            "EXEC\\s+SQL\\s+INCLUDE\\s+([a-zA-Z0-9\\-_]+)\\s+END-EXEC", 
            Pattern.CASE_INSENSITIVE
        );
        
        Matcher matcher = includePattern.matcher(text);
        if (matcher.find()) {
            return matcher.group(1).toUpperCase();
        }
        
        // Fallback to original regex if the above doesn't work
        try {
            return text.replaceAll(".*INCLUDE\\s+(\\w+)\\s+END-EXEC.*", "$1").toUpperCase();
        } catch (Exception e) {
            System.out.println("Could not extract INCLUDE name from: " + text);
            return null;
        }
    }

    /**
     * Helper method to check if a parse tree node represents a newline
     */
    private boolean isNewlineToken(ParseTree node) {
        if (node instanceof TerminalNode) {
            TerminalNode terminal = (TerminalNode) node;
            int tokenType = terminal.getSymbol().getType();
            return tokenType == CobolPreprocessorLexer.NEWLINE;
        }
        return false;
    }

    @Override
    public StringBuilder visitExecSqlImsStatement(CobolPreprocessorParser.ExecSqlImsStatementContext ctx) {
        String text = ctx.getText().replace(EXEC_SQLIMS_TAG, "EXEC SQLIMS").replace(EXEC_END_TAG, "END-EXEC");
        output.append(text).append(NEWLINE);
        return output;
    }

    @Override
    public StringBuilder visitEjectStatement(CobolPreprocessorParser.EjectStatementContext ctx) {
        return output;
    }

    @Override
    public StringBuilder visitSkipStatement(CobolPreprocessorParser.SkipStatementContext ctx) {
        return output;
    }

    @Override
    public StringBuilder visitTitleStatement(CobolPreprocessorParser.TitleStatementContext ctx) {
        return output;
    }


    private String applyReplacing(String content, CobolPreprocessorParser.ReplacingPhraseContext replacingPhrase) {
        if (replacingPhrase == null) {
            System.out.println("Invalid replacing phrase, skipping replacement.");
            return content;
        }
        
        String result = content;
        for (CobolPreprocessorParser.ReplaceClauseContext clause : replacingPhrase.replaceClause()) {
            String replaceable = clause.replaceable().getText();
            String replacement = clause.replacement().getText();
            
            // Handle pseudo-text replacement
            if (replaceable.startsWith("==") && replaceable.endsWith("==")) {
                String searchText = replaceable.substring(2, replaceable.length() - 2);
                String replaceText = replacement.startsWith("==") && replacement.endsWith("==") 
                    ? replacement.substring(2, replacement.length() - 2) 
                    : replacement;
                // For pseudo-text, match anywhere (not just word boundaries)
                Pattern pattern = Pattern.compile(Pattern.quote(searchText), Pattern.CASE_INSENSITIVE);
                result = pattern.matcher(result).replaceAll(replaceText);
            } else {
                // Regular word replacement
                Pattern pattern = Pattern.compile("\\b" + Pattern.quote(replaceable) + "\\b", Pattern.CASE_INSENSITIVE);
                result = pattern.matcher(result).replaceAll(replacement);
            }
        }
        return result;
    }

    private void loadCopyBooks(List<File> directories, List<String> extensions, Charset charset, Set<String> included) throws IOException {
        copyBooks.clear();
        for (File dir : directories) {
            if (!dir.isDirectory()) {
                System.out.println("Copybook directory is invalid: " + dir.getAbsolutePath());
                continue;
            }
            File[] files = dir.listFiles((d, name) -> {
                for (String ext : extensions) {
                    if (name.toLowerCase().endsWith("." + ext.toLowerCase())) {
                        return true;
                    }
                }
                return false;
            });
            if (files == null) {
                continue;
            }
            for (File file : files) {
                String key = file.getName().replaceFirst("[.][^.]+$", "").toUpperCase();
                if (included.contains(key)) {
                    System.out.println("Circular copybook dependency detected: " + key);
                    if (strictMode) {
                        throw new IOException("Circular copybook dependency: " + key);
                    }
                    continue;
                }
                included.add(key);
                try (BufferedReader reader = new BufferedReader(new FileReader(file, charset))) {
                    StringBuilder content = new StringBuilder();
                    String line;
                    while ((line = reader.readLine()) != null) {
                        content.append(line).append(NEWLINE);
                    }
                    String copyContent = content.toString();
                    Pattern copyPattern = Pattern.compile("(?i)^\\s*COPY\\s+(\\w+)\\s*(\\.)?(?:\\s*REPLACING\\s+(.+?)(?:\\.|$))?\\s*$", Pattern.MULTILINE);
                    Matcher matcher = copyPattern.matcher(copyContent);
                    StringBuilder resolvedContent = new StringBuilder();
                    int lastEnd = 0;
                    while (matcher.find()) {
                        resolvedContent.append(copyContent, lastEnd, matcher.start());
                        String nestedCopy = matcher.group(1).toUpperCase();
                        String replacing = matcher.group(3);
                        String nestedContent = copyBooks.getOrDefault(nestedCopy, null);
                        if (nestedContent == null) {
                            File nestedFile = findCopyBookFile(nestedCopy, directories, extensions);
                            if (nestedFile != null) {
                                Set<String> newIncluded = new HashSet<>(included);
                                loadCopyBook(nestedFile, charset, newIncluded);
                                nestedContent = copyBooks.get(nestedCopy);
                            }
                        }
                        if (nestedContent == null) {
                            System.out.println("Nested copybook not found: " + nestedCopy);
                            resolvedContent.append("COPY ").append(nestedCopy).append(" content not found.");
                        } else {
                            String processedContent = nestedContent;
                            if (replacing != null) {
                                CobolPreprocessorParser.ReplacingPhraseContext phraseContext = parseReplacingPhrase(replacing);
                                if (phraseContext != null) {
                                    processedContent = applyReplacing(processedContent, phraseContext);
                                } else {
                                    System.out.println("Skipping invalid REPLACING clause in copybook: " + replacing);
                                }
                            }
                            resolvedContent.append(processedContent);
                        }
                        lastEnd = matcher.end();
                    }
                    resolvedContent.append(copyContent, lastEnd, copyContent.length());
                    copyBooks.put(key, resolvedContent.toString());
                    System.out.println("Loaded copybook: " + file.getName());
                } catch (IOException e) {
                    System.out.println("Failed to load copybook " + file.getName() + ": " + e.getMessage());
                    if (strictMode) {
                        throw e;
                    }
                } finally {
                    included.remove(key);
                }
            }
        }
    }

    private File findCopyBookFile(String name, List<File> directories, List<String> extensions) {
        for (File dir : directories) {
            for (String ext : extensions) {
                File file = new File(dir, name + "." + ext);
                if (file.exists() && file.isFile()) {
                    return file;
                }
            }
        }
        return null;
    }

    protected void loadCopyBook(File file, Charset charset, Set<String> included) throws IOException {
        String key = file.getName().replaceFirst("[.][^.]+$", "").toUpperCase();
        if (included.contains(key)) {
            throw new IOException("Circular copybook dependency: " + key);
        }
        included.add(key);
        try (BufferedReader reader = new BufferedReader(new FileReader(file, charset))) {
            StringBuilder content = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line).append(NEWLINE);
            }
            copyBooks.put(key, content.toString());
        } finally {
            included.remove(key);
        }
    }

    private CobolPreprocessorParser.ReplacingPhraseContext parseReplacingPhrase(String replacingText) {
        try {
            CharStream input = CharStreams.fromString("REPLACING " + replacingText + ".");
            CobolPreprocessorLexer lexer = new CobolPreprocessorLexer(input);
            CommonTokenStream tokens = new CommonTokenStream(lexer);
            CobolPreprocessorParser parser = new CobolPreprocessorParser(tokens);
            return parser.replacingPhrase();
        } catch (Exception e) {
            System.out.println("Failed to parse replacing phrase: " + replacingText);
            return null;
        }
    }

public static void main(String[] args) throws IOException {
        if (args.length < 2) { 
            System.err.println("Usage: java CobolPreprocessorDriver <input.cbl> <output.cbl>");
            System.exit(1);
        }
        
        String inputFile = args[0];
        String outputFile = args[1];
        
        CobolPreprocessorDriver preprocessor = new CobolPreprocessorDriver();
        CobolParserParams params = new CobolParserParamsImpl();
        ((CobolParserParamsImpl) params).setFormat(CobolSourceFormatEnum.FIXED);
        ((CobolParserParamsImpl) params).setCopyBookDirectory(new File("./copybooks"));
        ((CobolParserParamsImpl) params).setCopyBookDirectories(Arrays.asList(new File("./copybooks")));
        ((CobolParserParamsImpl) params).setCopyBookExtensions(Arrays.asList("cbl", "cpy"));
        ((CobolParserParamsImpl) params).setCharset(Charset.defaultCharset()); 
        ((CobolParserParamsImpl) params).setStrictMode(true);
        
        String result = preprocessor.process(new File(inputFile), params);
        
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile))) {
            writer.write(result);
        }   
            
        System.out.println("Preprocessing completed. Output written to " + outputFile);
    }   
}

